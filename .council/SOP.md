# 六步自愈循环 SOP 详细流程 (2025 Optimized)

> 遵循 Dev Workflow 标准操作程序，通过多模型优势互补实现高效产出

## 流程图

```text
用户需求
    │
    ▼
┌──────────────────┐
│ 1. PM (Claude)   │ ← 长程规划、PRD、任务树 (5%)
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ 2. 架构 (Gemini) │ ← 2M 长上下文、全库审计 (5%)
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ 3. TDD (Flash)   │ ← TDD 先行、覆盖率 ≥ 90% (80%)
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ 4. 实现 (Flash)  │ ← 最小 Patch、迭代修复 (80%)
└────────┬─────────┘
         │
         ▼
┌──────────────────┐     ┌───────────┐
│ 5. 裁决 (verify) │────▶│ 自愈循环  │
└────────┬─────────┘     └─────┬─────┘
         │                     │
         │◀────────────────────┘
         ▼
┌──────────────────┐
│ 6. 审查 (Codex)  │ ← 代码审查、边界对齐 (10%)
└──────────────────┘
```

## 阶段详解

### 1. 需求代码化 (PM) - Claude Opus

**主控**: Claude Opus 4.5 (规划总控)

```markdown
输入: "帮我优化登录功能"
输出:
  - PRD: 问题/用户/非目标
  - 任务树: 5 个小步骤 (标注文件)
  - 验收标准: 可测试条件
  - 模型分发建议
```

### 2. 全库审计 (架构师) - Gemini Pro

**主控**: Gemini 3 Pro

```markdown
能力: 2M tokens 上下文
动作:
  - 扫描整个代码库
  - 发现新旧逻辑冲突
  - 输出技术设计文档
  - 前端 UI/UX 设计 (如需)
```

### 3. TDD 强制约束 (QA) - Gemini Flash

**主控**: Gemini 3 Flash

```markdown
规则: 测试覆盖率 < 90% 禁止执行
动作:
  - 根据设计文档写测试
  - 红灯验证 (测试应失败)
```

### 4. 程序化并行执行 - Gemini Flash

**主控**: Gemini 3 Flash

**Token 节省核心**:

```python
# 编写 Python 脚本批量操作，而非逐条自然语言指令
# Token 节省约 98.7%

import subprocess
files_to_modify = [...]
for f in files_to_modify:
    # 批量修改
    pass
```

### 5. 自愈校验

**命令**: `just verify`

**自愈循环**:

```text
运行测试 → 失败 → 提取错误日志 → 修复 → 重试
    ▲                                    │
    └────────────────────────────────────┘
```

**Wald 共识**:

- π 达置信上限 → 自动提交
- 分歧过大 → 人在回路审计

### 6. 代码审查 - Codex

**主控**: Codex 5.2 (修复审查)

```markdown
动作:
  - 代码审查与质量把关
  - 漏洞发现与安全审查
  - 边界对齐验证
  - 更新 NOTES.md
```

## 命令速查 (标准六步流程)

```bash
# 1. PM 规划 (Claude Opus) - 需求代码化
/plan "<需求描述>"
# 输出: PRD + 任务树 + 验收标准 → .council/BRIEF.md

# 2. 架构审计 (Gemini Pro) - 全库扫描
/audit "<功能/模块>"
# 输出: 冲突检测 + 设计文档

# 3. TDD 测试 (Gemini Flash) - 先写测试
/tdd "<任务范围>"
# 输出: 测试文件 + RED 验证

# 4. 最小实现 (Gemini Flash) - 通过测试
/impl "<任务范围>"
# 输出: 最小 patch + GREEN 验证

# 5. 验证裁决 - 自愈循环
/verify
# 或: just verify
# 输出: 编译 + lint + 测试全通过

# 6. 代码审查 (Codex) - 质量把关
/review
# 输出: 风险点 + 修复建议 + 总体评价
```

## 扩展命令 (可选)

```bash
# 发布前检查 (可选)
/ship "<版本号>"

# 模型委托 (特殊场景)
/delegate <model> "<任务>"
```
